

## 35. 并行和并发有什么区别？
* **并行是指两个或多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；**
* **并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；**
* **并发是在一台处理器上“同时”处理多个任务，并行是在多台处理器上同时处理多个任务，如hadoop分布式集群；**

所以并发编程的目标是充分地利用处理器的每一个核，以达到最高的处理性能；

## 36. 线程和进程的区别？
* **进程是资源分配最小单位，线程是程序执行的最小单位，一个程序至少有一个进程，一个进程至少有一个线程**
* **进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高；**
* **线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位**
* **线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；**
* **同一进程中的多个线程之间可以并发执行**

## 37. 守护线程是什么？
* **守护线程（即daemon thread），是个服务线程，准确来说就是服务其他的线程，最典型的就是垃圾回收**

## 38. 创建线程有哪几种方式？
* **1. 继承Thread类创建线程类**

  * **定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()
      方法称为执行体。**
  * **创建Thread子类的实例，即创建了线程对象。**
  * **调用线程对象的start()方法来启动该线程。**
* **2. 通过Runnable接口创建线程类**
  * **定义runnable接口的实现类，并重写该接口的run方法，该run方法的方法体同样是该线程的线程执行体。**
  * **创建Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。**
  * **调用线程对象的start()方法来启动该线程。**
* **3. 通过Callable和Future创建线程**
  * **创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。**
  * **创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。**
  * **使用FutureTask对象作为Thread对象的target创建并启动新线程。**
  * **调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。**

## 39. 说一下runnable和callable有什么区别？
  * **Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；**
  * **Callable()接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。**

## 40. 线程有哪些状态？
  线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。
  * **创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。**
  * **就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。**
  * **运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。**
  * **阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep、suspend、wait等方法都可以导致线程阻塞。**
  * **死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。**
  
## 41. sleep() 和 wait() 有什么区别？
sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。

因为sleep()是static静态的方法，它不能改变对象的机锁，当一个synchronized块中调用了sleep()方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。


wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。

## 42. notify()和notifyAll()有什么区别？
* **如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。**
* **notifyAll()方法唤醒所有wait线程，notify()方法只随机唤醒一个wait线程；被唤醒的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只有一个线程会由等待池进入锁池，而notifyAll()会将该对象等待池内所有线程移动到锁池中，等待锁竞争。**
* **优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有该线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。**

## 43. 线程的run()和start()有什么区别？
每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。
* **run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用run()，其实就相当于是调用了一个普通函数而已，必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有多程的特征**
* **start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；这时此线程是处于就绪状态，并没有运行。然后通过此Thread类调用方法run()来完成其运行状态，这里方法run()称为线程体，run()方法运行结束，此线程终止。然后cpu再调度其他线程。**

## 44. 创建线程池有哪几种方式？




